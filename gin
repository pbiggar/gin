#!/usr/bin/env python

# Read from the status file
import yaml
import gcc
import sys
import state
import pprint

def read_ginfile():
  stream = file("ginfile", "r")
  ginfile = yaml.load(stream)
  stream.close()
  return ginfile

def configure_meta_information(ginfile):
  meta = ginfile["meta"]
  return [
    '#define PACKAGE "%s"\n' % (meta["name"]),
    '#define VERSION "%s"\n' % (meta["version"]),
  ]

def configure_standard_dirs(ginfile):
  name = ginfile["meta"]["name"]

  prefix = "/usr/local"
  datadir = prefix + "/share"
  libdir = prefix + "/lib"
  pkglibdir = prefix + "/" + name
  return [
    '#define DATADIR "%s"\n' % (datadir),
    '#define PKGLIBDIR "%s"\n' % (pkglibdir),
  ]


# For multi-processing
def run_check(check):
  name = check["name"]
  print "Checking for " + name + '....',
  works = gcc.configure_test(check["test-program"], check["language"])
  print "yes" if works else "no"

  if works:
    defines = check.get("defines", [])
    libraries = check.get("libraries", [])
    return (defines, libraries)
  return ([], [])


def configure_checks(ginfile):
  checks = ginfile["configure"]
  for t in ginfile["targets"].values():
    checks.update (t["configure"])

  # Store the name in the object for passing to Pool.map
  for name,check in checks.items():
    check["name"] = name

  # Run checks in parallel
  from multiprocessing import Pool
  p = Pool(5)
  results = p.map(run_check, checks.values())

  libraries = [elem for tup in results for elem in tup[1]]
  libraries.sort()

  defines = [elem for tup in results for elem in tup[0]]
  lines = []
  for define in defines:
    if type(define) == 'dict':
      lines.append ('#define %s "%s"\n' % (define.keys()[0], define.values()[0]))
    else:
      lines.append ('#define %s\n' % (define))
  lines.sort()

  return (libraries, lines)


def configure(ginfile):

  (libraries, check_lines) = configure_checks(ginfile)
  meta_lines = configure_meta_information(ginfile)
  dir_lines = configure_standard_dirs(ginfile)

  config = file("config.h", "w")

  for l in meta_lines + dir_lines + check_lines:
    config.write(l)
  config.close()

  return libraries


def build(state, ginfile, config_libs):
  # state.add("config.h", [], configure, ())

  targets = ginfile["targets"]
  for (name, struct) in targets.items():
    files = struct["files"]
    libs = struct["libraries"] + config_libs
    includes = struct["includes"]
    includes += ['.'] # For config.h
    defs = {"HAVE_CONFIG_H": None}

    objs = []
    for f in files:
      obj = gcc.get_output_file(f)
      objs += [obj]
      state.add(obj, f, gcc.build_object, (f, includes, defs))

    # link steps
    state.add(name, objs, gcc.link, (name, objs, libs))

#source_file -> parent_file (bison etc)

ginstate = state.load()
try:
  # Don't forget to make this depend on ginfile
  if not ginstate:
    ginstate = state.State()
    ginfile = read_ginfile()
    build(ginstate, ginfile, configure(ginfile))

  ginstate.process()

  # Debugging
#  for k,v in ginstate._chain.items():
#    print k + ": \n"
#    pprint.pprint(vars(v))

except:
  print "Saving state"
  ginstate.save()
  raise

print "Saving state"
ginstate.save()
