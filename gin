#!/usr/bin/env python

# Read from the status file
import yaml
import gcc

def read_ginfile():
  stream = file("ginfile", "r")
  ginfile = yaml.load(stream)
  stream.close()
  return ginfile

def configure(ginfile):

  config = file("config.h", "w")

  # Autoconf-like meta information
  meta = ginfile["meta"]
  config.write('#define PACKAGE "%s"\n' % (meta["name"]))
  config.write('#define VERSION "%s"\n' % (meta["version"]))
  config.write('\n');

  # Standard GNU directories
  prefix = "/usr/local"
  datadir = prefix + "/share"
  libdir = prefix + "/lib"
  pkglibdir = prefix + "/" + meta["name"]
  config.write('#define DATADIR "%s"\n' % (datadir))
  config.write('#define PKGLIBDIR "%s"\n' % (pkglibdir))
  config.write('\n');


  # configure checks
  optionals = [t["optional"] for t in ginfile["targets"].values()]

  libraries = []
  defines = []

  for optional in optionals:
    for name,value in optional.items():
      print "Checking for " + name + '....'
      works = gcc.configure_test(value["test"], value["language"])
      print "yes" if works else "no"

      if works:
        defines += value["defines"]
        libraries += value["libraries"]

  for define in defines:
    if type(define) == 'dict':
      config.write('#define %s "%s"\n' % (define.keys()[0], define.values()[0]))
    else:
      config.write('#define %s\n' % (define))
  config.write('\n');


  config.close()

  return libraries

def build(ginfine, config_libs):
  targets = ginfile["targets"]
  for (name, struct) in targets.items():
    files = struct["files"]
    libs = struct["libraries"] + config_libs
    includes = struct["includes"]
    includes += ['.'] # For config.h
    defs = {"HAVE_CONFIG_H": None}

    # Build them with gcc
    objs = []
    for filename in files:
      objs += [gcc.build_object(filename, includes, defs)]

    # Link
    gcc.link(name, objs, libs)


ginfile = read_ginfile()
config_libs = configure(ginfile)
build(ginfile, config_libs)
