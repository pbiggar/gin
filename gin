#!/usr/bin/env python

# Read from the status file
import yaml
import gcc
import sys

def read_ginfile():
  stream = file("ginfile", "r")
  ginfile = yaml.load(stream)
  stream.close()
  return ginfile

def configure_meta_information(ginfile):
  meta = ginfile["meta"]
  return [
    '#define PACKAGE "%s"\n' % (meta["name"]),
    '#define VERSION "%s"\n' % (meta["version"]),
  ]

def configure_standard_dirs(ginfile):
  name = ginfile["meta"]["name"]

  prefix = "/usr/local"
  datadir = prefix + "/share"
  libdir = prefix + "/lib"
  pkglibdir = prefix + "/" + name
  return [
    '#define DATADIR "%s"\n' % (datadir),
    '#define PKGLIBDIR "%s"\n' % (pkglibdir),
  ]


# For multi-processing
def run_check(check):
  name = check["name"]
  print "Checking for " + name + '....',
  works = gcc.configure_test(check["test-program"], check["language"])
  print "yes" if works else "no"

  if works:
    defines = check.get("defines", [])
    libraries = check.get("libraries", [])
    return (defines, libraries)
  return ([], [])


def configure_checks(ginfile):
  checks = ginfile["configure"]
  for t in ginfile["targets"].values():
    checks.update (t["configure"])

  # Store the name in the object for passing to Pool.map
  for name,check in checks.items():
    check["name"] = name

  # Run checks in parallel
  from multiprocessing import Pool
  p = Pool(5)
  results = p.map(run_check, checks.values())

  libraries = [elem for tup in results for elem in tup[1]]
  libraries.sort()

  defines = [elem for tup in results for elem in tup[0]]
  lines = []
  for define in defines:
    if type(define) == 'dict':
      lines.append ('#define %s "%s"\n' % (define.keys()[0], define.values()[0]))
    else:
      lines.append ('#define %s\n' % (define))
  lines.sort()

  return (libraries, lines)


def configure(ginfile):

  (libraries, check_lines) = configure_checks(ginfile)
  meta_lines = configure_meta_information(ginfile)
  dir_lines = configure_standard_dirs(ginfile)

  config = file("config.h", "w")

  for l in meta_lines + dir_lines + check_lines:
    config.write(l)
  config.close()

  return libraries

def b((f, l, i, d)):
  return gcc.build_object(f,i,d)


def build(ginfine, config_libs):
  targets = ginfile["targets"]
  for (name, struct) in targets.items():
    files = struct["files"]
    libs = struct["libraries"] + config_libs
    includes = struct["includes"]
    includes += ['.'] # For config.h
    defs = {"HAVE_CONFIG_H": None}

    # Build them with gcc
    from multiprocessing import Pool
    p = Pool(5)
    obj_list = p.map(b, [(f, libs, includes, defs) for f in files])
    objs = [obj for objs in obj_list for obj in objs]

    # Link
    gcc.link(name, objs, libs)


ginfile = read_ginfile()

# Simple command parsing for now
command = sys.argv[1] if len(sys.argv) > 1 else None
if command == "configure-compatibility-mode":
  compatibility_mode_configure(ginfile)
elif command == "make-compatibility-mode":
  compatibility_mode_make(ginfile)
elif command == None:
  build(ginfile, configure(ginfile))
