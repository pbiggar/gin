#!/usr/bin/env python

import os
import subprocess
import threading
import sys
import re

def run(args):
  class ThreadWorker(threading.Thread):
    def __init__(self, pipe):
      super(ThreadWorker, self).__init__()
      self.all = ""
      self.pipe = pipe
      self.setDaemon(True)

    def run(self):
      while True:
        line = self.pipe.readline()
        if line == '': break
        else:
          self.all += line

  try:
    print args
    proc = subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdout_worker = ThreadWorker(proc.stdout)
    stderr_worker = ThreadWorker(proc.stderr)
    stdout_worker.start()
    stderr_worker.start()

    proc.wait()
    stdout_worker.join()
    stderr_worker.join()

  except KeyboardInterrupt, e:
    pass

  stdout, stderr = stdout_worker.all, stderr_worker.all
  result = (stdout, stderr, proc.returncode)
  return result


def find_filetypes(types):
  sources = []
  for (dirpath, dirnames, filenames) in os.walk('.'):
    for file in filenames:
      for type in types:
        if file.endswith("." + type):
          sources.append(os.path.join(dirpath, file))
          break

  return sources



class System:
  def __init__(self):
    self.headers = self._headers()
    self.sources = self._sources()

  def _headers(self):
    return find_filetypes (['h'])

  def _sources(self):
    return find_filetypes (['cpp', 'c'])

  def try_building(self):
    for chain in self.chains:
      if not chain.build():
        print "Could not build %s, will try again if necessary" % chain.source
        continue




  def go(self):
    self.chains = [Chain(system, source) for source in self.sources]
    self.try_building()

    dependencies = ["_main"]
    required = []

    while len(dependencies):
      d = dependencies.pop(0)
      print "Finding dependency: " + d
      for chain in self.chains:
        if ('T', d) in chain.symbols:
          dependencies += chain.dependencies()
          required += [chain]

    self.link(required)


  def link(self, required_chains):
    args = ['gcc', '-o', 'main'] + [c.object for c in required_chains]
    codes = run(args)
    print codes







class Chain:
  def __init__(self, system, source):
    self.system = system
    self.source = source
    self.object = None

  def build(self):
    object = self.source + '.o'
    args = ['gcc', '-c', self.source, '-o', object]
    while True:
      (out, error, exit) = run(args)
      if exit == 0:
        self.object = object
        self.read_symbols()
        return True

      print "Couldn't compile %s: (%s, %s)" % (source, out, error)
      redo = False

      for line in error.split('\n'):
        pat = re.match(".*error: (.+): No such file or directory", line)
        if pat != None:
          header = pat.group(1)
          matching = [h for h in headers if h.endswith('/' + header)]
          if len(matching) == 0:
            print "No headers match, skip it: " + header
            return False
          elif len(matching) != 1:
            print "More than one header matches: " + header + " - " + str(matching)
            raise TODO()

          m = matching[0]
          dir = m[0:-len(header)]
          args += ['-I', dir]
          redo = True
          break

        pat = re.match("In file included from .*:$", line)
        if pat:
          continue

        pat = re.match(".*: warning: .*", line)
        if pat:
          continue

        print "Didnt match, ignoring: " + line

      if redo:
        print "Trying again"
      else:
        print "Giving up"
        return False

  def is_main(self):
    # TODO: structure it as property accesses which are cached
    self.build()

    if not self.object:
      return False

    return ('T', "_main") in self.symbols

  def dependencies(self):
    return [sym for (type, sym) in self.symbols if type == 'U']

  def read_symbols(self):
    (output, _, exitcode) = run (['nm', self.object])
    assert exitcode == 0
    result = []
    print output
    for line in output.strip().split('\n'):
      if len(line) == 0: # ignore blanks
        continue

      if line[0] == ' ': # tuple
        (type, name) = line.split()
      else: # triple
        (_, type, name) = line.split()
      result.append ((type, name))

    print "Found symbols " + str(result)
    self.symbols = result



system = System()
system.go()


